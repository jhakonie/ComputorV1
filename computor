#!/usr/bin/python

import math
import sys

class polynomial_context:
	def __init__(self, a, b, c):
		self.a = a
		self.b = b
		self.c = c
		self.no_solution = False
		self.only_one_result = False
		self.infinite_results = False
		self.discriminant = self.b * self.b - 4 * self.a * self.c
		self.denominator = 2 * self.a
		if (self.discriminant < 0 or self.denominator == 0):
			self.no_solution = True
		else:
			if (self.discriminant == 0):
				self.only_one_result = True
			self.numerator_0 = -b + math.sqrt(self.discriminant)
			self.numerator_1 = -b - math.sqrt(self.discriminant)
			self.result_0 = self.numerator_0 / self.denominator
			self.result_1 = self.numerator_1 / self.denominator
			if (self.result_0 == 0 and self.result_1 == 0):
				self.infinite_results = True

# def solve_polynomial()

class monomial:
	def __init__(self, string, exponent, coefficient, sign): #remove string?
		self.str = string
		self.exponent = exponent
		self.coefficient = coefficient * sign
		self.sign = sign
		# if (self.coefficient < 0):
		# 	self.sign = -1
		# self.string = ""
		# self.string += str(self.coefficient) + " * X^" + str(self.exponent)

	def set_monomial(self, exponent, coefficient, sign):
		self.exponent = exponent
		self.coefficient += (coefficient * sign)
		if (self.coefficient < 0):
			self.sign = -1
		else:
			self.sign = 1
		# self.str = ""
		# self.str += str(self.coefficient * sign) + " * X^" + str(self.exponent)

def parse_monomial(i, equation, polynomials, equation_len, equal):
	sign = 1
	monomial_to_set = 0
	coefficient = float(equation[i])
	monomial_len = 1
	# checking if the monomial is negative or on the right side of the equal sign
	if (i > 0):
		if ((equation[i - 1] == "-" and equal == False) or (equation[i - 1] != "-" and equal == True)):
			sign = -1
	# checking that there is a * sign
	if (i + 1 < equation_len and equation[i + 1] == "*"):
		monomial_len += 1
	else:
		print("incorrect syntax '*' missing")
		return -1
	# checking that there is X, else: error message and exit
	if (i + 2 < equation_len and "X" in equation[i + 2]):
		# checking that there is ^, else: error message and exit
		if ("^" in equation[i + 2]):
			temp = []
			# splitting the X and the exponent
			temp = equation[i + 2].split("^")
			if (len(temp) != 2):
				print("error exponent missing after ^")
				return -1
			exponent_str = temp[1]
			exponent = int(exponent_str)
			len_polynomials = len(polynomials)
			exponent_found = False
			# checking if a monomial with the same exponent already exists in polynomials list
			for i in range(len_polynomials):
				if (polynomials[i].exponent == exponent):
					index = i
					exponent_found = True
			# if it exists already, adding the coeficient to the existing one
			if (exponent_found):
				polynomials[index].set_monomial(exponent, coefficient, sign)
			# if not, adding a new monomial to the end of polynomials
			else:
				polynomials.append( monomial("", exponent, coefficient, sign) )
			monomial_len += 1
		else:
			print("error no ^ after X")
			return -1
	else:
		print("error no X after *")
		return -1
	return (monomial_len)

def print_result(polynomials):
	reduced_form = "Reduced form: "
	polynomial_degree = 0
	polynomials.sort(key = lambda x: x.exponent, reverse = False)
	len_polynomials = len(polynomials)
	i = 0
	while (i < len_polynomials):
		if (polynomials[i].sign < 0):
			reduced_form += "- "
		else:
			reduced_form += "+ "
		reduced_form += str(polynomials[i].coefficient * polynomials[i].sign) + " * X^" + str(polynomials[i].exponent) + " "
		if (polynomial_degree < polynomials[i].exponent):
			polynomial_degree = polynomials[i].exponent
		i += 1
	reduced_form += "= 0"
	print(reduced_form)

	print("Polynomial degree: " + str(polynomial_degree))

	if (polynomial_degree > 2):
		print ("The polynomial degree is strictly greater than 2, I can't solve.")
		return
	elif (len_polynomials == 3):
		solver = polynomial_context(polynomials[0].coefficient, polynomials[1].coefficient, polynomials[2].coefficient)
		if (solver.no_solution):
			print("discriminant < 0 or denominator == 0, no solution")
		elif (solver.only_one_result):
			print("Result is:" + str(solver.result_0))
		elif (solver.infinite_results):
			print("Each real number is a solution")
		else:
			print("Discriminant is strictly positive, the two solutions are:")
			print(str(solver.result_0))
			print(str(solver.result_1))

def main():
	if (len(sys.argv) == 2):
		argument = sys.argv[1]

		equation = []
		# a list of polynomial terms of an equation, for example: a * x^2 + b * x + c = 0
		polynomials = []

		# splitting the argument into strings/tokens
		equation = argument.split(" ")
		# print(equation)

		# keeping track of the number of tokens in the equation
		equation_len = len(equation)
		# print(equation_len)

		# keeping track of the equal sign, 0 means it hasn't passed yet
		equal = False
		i = 0
		while (i < equation_len):
			if (equation[i][0] == "="):
				equal = True
				i += 1
			# a token begins with a number, if found, start parsing the polynomial term
			if (equation[i][0].isnumeric()):
				j = parse_monomial(i, equation, polynomials, equation_len, equal)
				# check for possible error encountered in parsing and quit
				if (j == -1):
					return
				# otherwise parse_monomial returns the length of the term parsed in tokens
				i += j
			# if a number was not found, moving to the next token
			else:
				i += 1
		print_result(polynomials)
	else:
		print("usage: python3 computor \"equation\"")
main()

# python3 computor "1 * X^2 + 2 * X^1 - 2 * X^0 = 3"
# python3 computor "1 * X^2 + 2 * X^1 - 2 * X^0 = 8 * X^2 - 3 * X^0"
